<?php
// $Id$

/**
 * @file
 * Test the fast-import bridge for PHP.
 *
 * Check a number of conditions to ensure the proper function of the
 * GitFastImport class of gitlib.
 *
 * Copyright 2009 by Daniel Hackney ("dhax", http://drupal.org/user/384635)
 */

require_once(dirname(__FILE__) . '/../git.php');
class GitLibFastImportTestCase extends DrupalWebTestCase {

  public static function getInfo() {
    return array(
      'name' => t('Fast Import'),
      'description' => t('Verify that Fast Import integration works correctly.'),
      'group' => t('GitLib'),
    );
  }

  function setUp() {
    parent::setUp();
    $tempfile = tempnam('','');
    if (file_exists($tempfile)) { unlink($tempfile); }
    mkdir($tempfile);
    $this->repo_dir = $tempfile;

    $command = sprintf('GIT_DIR=%s git init', escapeshellarg($this->repo_dir));
    shell_exec($command);

    $this->fast = new GitFastImport($this->repo_dir);
  }

  function tearDown() {
    recursive_remove_directory($this->repo_dir);
    parent::tearDown();
  }

  /**
   * Helper for asserting the success of a fast-import execution.
   *
   * @param $retval
   *   The return value from fastImport().
   *
   * @param $group
   *   The group to set for the SimpleTest assertion.
   *
   * @return
   *   None.
   */
  function assertCommandSuccess($retval, $group) {
    $this->assertEqual(
      $retval,
      0,
      t('Command completes successfully.'),
      $group
    );
  }

  /**
   * Helper for asserting that no marks were created in the execution of
   * fast-import.
   *
   * @param $marks
   *   The $marks return value from fastImport().
   *
   * @param $group
   *   The group to set for the SimpleTest assertion.
   *
   * @return
   *   None.
   */
  function assertNoMarks($marks, $group) {
    $this->assertFalse(
      $marks,
      t('Command produced no marks.'),
      $group
    );
  }

  /**
   * Helper for asserting that the command produced statistics (which will
   * happen on a successful run).
   *
   * @param $stderr
   *   The stderr result from GitFastImport::fastImport().
   *
   * @param $group
   *   The group to set for the SimpleTest assertion.
   *
   * @return
   *   None.
   */
  function assertStatisticsExists($stderr, $group) {
    $this->assertTrue(
      is_int(strpos($stderr, 'git-fast-import statistics:')),
      t('Command produces statistics.'),
      $group
    );
  }

  /**
   * Helper to check for the existence and value of a particular mark pointing
   * to a blob.
   *
   * @param $marks
   *   The marks return value from GitFastImport::fastImport().
   *
   * @param $mark_id
   *   The id number of the mark to find.
   *
   * @param $mark_data
   *   The expected data of the mark. This must exactly match the data contained
   *   in the mark for the assertion to pass.
   *
   * @param $group
   *   The group to set for the SimpleTest assertion.
   */
  function assertMarkBlob($marks, $mark_id, $mark_data, $group) {
    $this->assertNotNull(
      $marks[$mark_id],
      t('Mark exists in output.'),
      $group
    );

    $type = shell_exec(sprintf('GIT_DIR=%s git cat-file -t %s',
              escapeshellarg($this->repo_dir),
              $marks[$mark_id]));
    $this->assertTrue(
      is_int(strpos($type, 'blob')),
      t('Mark is of type "blob".'),
      $group
    );

    $data = shell_exec(sprintf('GIT_DIR=%s git cat-file blob %s',
              escapeshellarg($this->repo_dir),
              $marks[$mark_id]));
    $this->assertIdentical(
      $data,
      $mark_data,
      t('Expected data matches recorded mark'),
      $group
    );
  }

  /**
   * Perform an assertIdentical(), but only if $expected is not NULL.
   */
  function assertIfSet($actual, $expected, $message, $group) {
    if (isset($expected)) {
      $this->assertIdentical(
        $actual,
        $expected,
        t($message. ' matches expected.'),
        $group
      );
    }
  }


  /**
   * Helper to check for the existence and value of a particular mark pointing
   * to a commit. Does not completely check all aspects of a commit, but just
   * enough to ensure that the commit is there and is consistent.
   *
   * @param $marks
   *   The marks output parameter from GitFastImport::fastImport().
   *
   * @param $mark_id
   *   The id of the mark to check.
   *
   * @param $mark_data
   *   An array containing data about the commit. Any array elements not
   *   included will not be checked. The array is of the form:
   *
   *   array(
   *     'tree' => 'SHA-1',
   *     'author' => array(
   *       'name' => "name",
   *       'email' => "name@example.com",
   *       'when' => array(
   *         'time' => 1245480094,
   *         'offutc' => '+0000',
   *       ),
   *     ),
   *     'committer' => array(
   *       'name' => "name",
   *       'email' => "name@example.com",
   *       'when' => array(
   *         'time' => 1245480094,
   *         'offutc' => '+0000',
   *       ),
   *     ),
   *     'message' => 'commit message',
   *   )
   *
   * @param $group
   *   The group to set for the SimpleTest assertion.
   */
  function assertMarkCommit($marks, $mark_id, $mark_data, $group) {
    $this->assertNotNull(
      $marks[$mark_id],
      t('Mark exists in output.'),
      $group
    );

    $type = shell_exec(sprintf('GIT_DIR=%s git cat-file -t %s',
              escapeshellarg($this->repo_dir),
              $marks[$mark_id]));
    $this->assertTrue(
      is_int(strpos($type, 'commit')),
      t('Mark is of type "commit".'),
      $group
    );

    $data = shell_exec(sprintf('GIT_DIR=%s git cat-file commit %s',
              escapeshellarg($this->repo_dir),
              $marks[$mark_id]));

    // Ack, aughh, hurk! Matches the output of 'git cat-file commit <SHA-1>'
    $pattern = "/tree ([0-9a-f]{40})\n".
               "author (.+) <(.+)> (\d+) ([-+]\d{4})\n".
               "committer (.+) <(.+)> (\d+) ([-+]\d{4})\n".
               "\n(.*)\n/"; // Commit message
    $this->assertTrue(
      preg_match($pattern, $data, $matches),
      t('Commit message is printed in the correct format.'),
      $group
    );
    $tree = $matches[1];
    $author_name = $matches[2];
    $author_email = $matches[3];
    $author_date = $matches[4];
    $author_tz = $matches[5];
    $committer_name = $matches[6];
    $committer_email = $matches[7];
    $committer_date = $matches[8];
    $commtter_tz = $matches[9];
    $commit_message = $matches[10];

    // Check each of the attributes.
    $this->assertIfSet($tree, $match_data['tree'], 'Tree SHA-1', $group);
    $this->assertIfSet($author_name, $match_data['author']['name'], 'Author name', $group);
    $this->assertIfSet($author_email, $match_data['author']['email'], 'Author email', $group);
    $this->assertIfSet($author_date, $match_data['author']['when']['time'], 'Author date', $group);
    $this->assertIfSet($author_tz, $match_data['author']['when']['offutc'], 'Author timezone', $group);
    $this->assertIfSet($committer_name, $match_data['committer']['name'], 'Committer name', $group);
    $this->assertIfSet($committer_email, $match_data['committer']['email'], 'Committer email', $group);
    $this->assertIfSet($committer_date, $match_data['committer']['when']['time'], 'Committer date', $group);
    $this->assertIfSet($committer_tz, $match_data['committer']['when']['offutc'], 'Committer timezone', $group);
    $this->assertIfSet($commit_message, $match_data['message'], 'Commit message', $group);
  }

  /**
   * Helper to check for the creation of a certain number of objects as a result
   * of a fast-import.
   *
   * @param $stderr
   *   The stderr output from GitFastImport::fastImport().
   *
   * @param $type
   *   The type of object to check. One of 'blobs', 'trees', 'commits', 'tags',
   *   'marks'.
   *
   * @param $counts
   *   The expected number of objects as an array. The form is:
   *
   *     array(
   *       'created' => 1,
   *       'duplicates' => 0,
   *     )
   *
   *   If $type is set to 'marks', then the expected format is:
   *
   *     array(
   *       'created' => 1024,
   *       'unique' => 1
   *     )
   *
   *   If an option is omitted, it will not be checked.
   *
   * @param $group
   *   The group to set for the SimpleTest assertion.
   */
  function assertObjectStats($stderr, $type, $counts, $group) {
    $pattern = '/ {6}%s {0,3}: +(?<created>\d+) \( +(?<dup>\d+) (?:duplicates|unique)/';
    $pattern = sprintf($pattern, preg_quote($type));
    $this->assertTrue(
      preg_match($pattern, $stderr, $matches),
      t('Type found in statistics.'),
      $group
    );
    $created = intval($matches['created']);
    $duplicates = $unique = intval($matches['dup']);

    if (isset($counts['created'])) {
      $this->assertIdentical(
        $created,
        intval($counts['created']),
        t('Number of created objects matches expectation.'),
        $group
      );
    }

    switch ($type) {
      case 'blobs':
      case 'trees':
      case 'commits':
      case 'tags':
        if (isset($counts['duplicates'])) {
          $this->assertIdentical(
            $duplicates,
            intval($counts['duplicates']),
            t('Number of duplicate objects matches expectation.'),
            $group
          );
        }
      break;
      case 'marks':
        if (isset($counts['unique'])) {
          $this->assertIdentical(
            $unique,
            intval($counts['unique']),
            t('Number of unique marks matches expectation.'),
            $group
          );
        }
      break;
      default:
        $this->fail(
          t('Wrong type given to assertObjectStats().'),
          $group
        );
    }
  }

  /**
   * Test the functionality of GitFastImport::buildCommandLine().
   */
  public function testBuildCommandLine() {
    $command = 'git fast-import ';
    $expected = $command;
    $this->assertEqual(
      $expected,
      $this->fast->buildCommandLine(),
      'Correctly returns just the bare command.',
      'buildCommandLine()'
    );

    $default_opts = '--date-format=raw --stats ';
    $expected = $command . $default_opts;
    $this->assertEqual(
      $expected,
      $this->fast->buildCommandLine($this->fast->defaultOptions()),
      'Correctly returns the command with default arguments.',
      'buildCommandLine()'
    );

    $pack_size = rand();
    $file_name = $this->randomName();
    $opts_args = array(
      'quiet',
      'force',
      'max-pack-size' => $pack_size,
      'export-pack-edges' => $file_name,
    );
    $opts = '--quiet --force --max-pack-size=%s --export-pack-edges=%s ';
    $expected = $command . $default_opts . sprintf($opts, $pack_size, $file_name);
    $this->assertEqual(
      $expected,
      $this->fast->buildCommandLine(array_merge($this->fast->defaultOptions(), $opts_args)),
      'Correctly format supplied arguments.',
      'buildCommandLine()'
    );
  }

  /**
   * Test running fast-import with no input. Requires a repository, but will not
   * produce any commits.
   */
  function testEmptyCommand() {
    $group = t('Empty command');
    list($retval, $marks, $stdout, $stderr) = $this->fast->fastImport(array(), array());
    $this->assertCommandSuccess($retval, $group);
    $this->assertNoMarks($marks, $group);
    $this->assertStatisticsExists($stderr, $group);
  }

  /**
   * Test the 'progress' command of fast-import.
   */
  function testProgressCommand() {
    $group = t('progress command');
    // Generate some messages
    $messages[] = $this->randomName();
    $messages[] = $this->randomName();
    $messages[] = $this->randomName();
    $messages[] = $this->randomName();

    foreach ($messages as $message) {
      $commands[] = array(
        'command' => 'progress',
        'message' => $message,
      );
    }

    $options = array();
    list($retval, $marks, $stdout, $stderr) = $this->fast->fastImport($commands, $options);

    $this->assertCommandSuccess($retval, $group);
    $this->assertNoMarks($marks, $group);

    foreach($messages as $message) {
      $this->assertTrue(
        is_int(strpos($stdout, 'progress '. $message)),
        t('Make sure assigned message appears in stdout.'),
        $group
      );
    }
  }

  /**
   * Test the 'checkpoint' command.
   */
  function testCheckpointCommand() {
    $group = t('checkpoint command');
    $commands[] = array(
      'command' => 'checkpoint',
    );
    $options = array();
    list($retval, $marks, $stdout, $stderr) = $this->fast->fastImport($commands, $options);

    $this->assertCommandSuccess($retval, $group);
    $this->assertNoMarks($marks, $group);
  }

  /**
   * Test the 'blob' command.
   */
  function testBlobCommand() {
    $group = t('blob command');
    $data_marked = $this->randomName();
    $data_unmarked = $this->randomName();
    $mark_id = rand(1, GitFastImport::MARK_ID_MAX);
    $options = array();
    $commands[] = array(
      'command' => 'blob',
      'mark' => $mark_id,
      'data' => $data_marked,
    );

    $commands[] = array(
      'command' => 'blob',
      'data' => $data_unmarked,
    );
    list($retval, $marks, $stdout, $stderr) = $this->fast->fastImport($commands, $options);

    $this->assertCommandSuccess($retval, $group);
    $this->assertMarkBlob($marks, $mark_id, $data_marked, $group);
    $counts = array(
      'created' => 2,
      'duplicates' => 0,
    );
    $this->assertObjectStats($stderr, 'blobs', $counts, $group);
    $counts = array(
      'unique' => 1,
    );
    $this->assertObjectStats($stderr, 'marks', $counts, $group);

    // Test MARK_ID_MAX
    $commands[] = array(
      'command' => 'blob',
      'mark'    => GitFastImport::MARK_ID_MAX + 1,
      'data'    => $data_marked,
    );

    try {
      list($retval, $marks, $stdout, $stderr) = $this->fast->fastImport($commands, $options);
      $this->fail(t('Oversize mark was not rejected.'), $group);
    } catch (Exception $e) {
      $this->pass(t('Oversize mark rejected.'), $group);
    }
  }

  /**
   * Test the 'commit' command.
   */
  function testCommitCommand() {
    $group    = t('commit command');
    $options  = array();
    $name     = $this->randomName();
    $time     = rand(0, time());
    $email    = sprintf('%s@%s.com', $this->randomName(), $this->randomName());
    $message  = $this->randomName();
    $contents = $this->randomName();
    $path     = $this->randomName();
    $mark     = rand(1, GitFastImport::MARK_ID_MAX);

    // Create a simple sample commit.
    $commands[] = array(
      'command' => 'commit',
      'ref' => 'master',
      'mark' => $mark,
      'committer' => array(
        'name' => $name,
        'email' => $email,
        'when' => array(
          'time' => $time,
          'offutc' => '+0000',
        ),
      ),
      'message' => $message,
      'operations' => array(
        array(
          'operation' => 'filemodify',
          'mode' => 'normal',
          'data' => $contents,
          'path' => $path,
        ),
      ),
    );
    list($retval, $marks, $stdout, $stderr) = $this->fast->fastImport($commands, $options);

    $this->assertCommandSuccess($retval, $group);
    $counts = array(
      'created' => 1,
      'duplicates' => 0,
    );
    $this->assertObjectStats($stderr, 'commits', $counts, $group);

    $counts = array(
      'unique' => 1,
    );
    $this->assertObjectStats($stderr, 'marks', $counts, $group);
    $this->assertMarkCommit($marks, $mark, $commands[0], $group);
  }
}
// ------------ lixlpixel recursive PHP functions -------------
// recursive_remove_directory( directory to delete, empty )
// expects path to directory and optional TRUE / FALSE to empty
// ------------------------------------------------------------
function recursive_remove_directory($directory, $empty=FALSE) {
  if(substr($directory,-1) == '/') {
    $directory = substr($directory,0,-1);
  }
  if(!file_exists($directory) || !is_dir($directory)) {
    return FALSE;
  } elseif(is_readable($directory)) {
    $handle = opendir($directory);
    while (FALSE !== ($item = readdir($handle))) {
      if($item != '.' && $item != '..') {
        $path = $directory.'/'.$item;
        if(is_dir($path)) {
          recursive_remove_directory($path);
        } else {
          unlink($path);
        }
      }
    }
    closedir($handle);
    if($empty == FALSE) {
      if(!rmdir($directory)) {
        return FALSE;
      }
    }
  }
  return TRUE;
}
