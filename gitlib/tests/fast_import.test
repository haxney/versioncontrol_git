<?php
// $Id$

/**
 * @file
 * Test the fast-import bridge for PHP.
 *
 * Check a number of conditions to ensure the proper function of the
 * GitFastImport class of gitlib.
 *
 * Copyright 2009 by Daniel Hackney ("dhax", http://drupal.org/user/384635)
 */

require_once(dirname(__FILE__) . '/../git.php');
class GitLibFastImportTestCase extends DrupalWebTestCase {

  public static function getInfo() {
    return array(
      'name' => t('Fast Import'),
      'description' => t('Verify that Fast Import integration works correctly.'),
      'group' => t('GitLib'),
    );
  }

  function setUp() {
    parent::setUp();
    $tempfile = tempnam('','');
    if (file_exists($tempfile)) { unlink($tempfile); }
    mkdir($tempfile);
    $this->tempdir = $tempfile;

    $command = sprintf('GIT_DIR=%s git init', escapeshellarg($this->tempdir));
    shell_exec($command);

    $this->fast = new GitFastImport($this->tempdir);
  }

  function tearDown() {
    recursive_remove_directory($this->tempdir);
    parent::tearDown();
  }

  /**
   * Helper for asserting the success of a fast-import execution.
   *
   * @param $retval
   *   The return value from fastImport().
   *
   * @param $group
   *   The group to set for the SimpleTest assertion.
   *
   * @return
   *   None.
   */
  function assertCommandSuccess($retval, $group) {
    $this->assertEqual(
      $retval,
      0,
      t('Command completes successfully.'),
      $group
    );
  }

  /**
   * Helper for asserting that no marks were created in the execution of
   * fast-import.
   *
   * @param $marks
   *   The $marks return value from fastImport().
   *
   * @param $group
   *   The group to set for the SimpleTest assertion.
   *
   * @return
   *   None.
   */
  function assertNoMarks($marks, $group) {
    $this->assertFalse(
      $marks,
      t('Command produced no marks.'),
      $group
    );
  }

  /**
   * Helper for asserting that the command produced statistics (which will
   * happen on a successful run).
   *
   * @param $stderr
   *   The stderr result from GitFastImport::fastImport().
   *
   * @param $group
   *   The group to set for the SimpleTest assertion.
   *
   * @return
   *   None.
   */
  function assertStatistics($stderr, $group) {
    $this->assertTrue(
      is_int(strpos($stderr, 'git-fast-import statistics:')),
      t('Command produces statistics.'),
      $group
    );
  }

  /**
   * Test the functionality of GitFastImport::buildCommandLine().
   */
  public function testBuildCommandLine() {
    $command = 'git fast-import ';
    $expected = $command;
    $this->assertEqual(
      $expected,
      $this->fast->buildCommandLine(),
      'Correctly returns just the bare command.',
      'buildCommandLine()'
    );

    $default_opts = '--date-format=raw --stats ';
    $expected = $command . $default_opts;
    $this->assertEqual(
      $expected,
      $this->fast->buildCommandLine($this->fast->defaultOptions()),
      'Correctly returns the command with default arguments.',
      'buildCommandLine()'
    );

    $pack_size = 4095;
    $file_name = 'random/name';
    $opts_args = array(
      'quiet',
      'force',
      'max-pack-size' => $pack_size,
      'export-pack-edges' => $file_name,
    );
    $opts = '--quiet --force --max-pack-size=%s --export-pack-edges=%s ';
    $expected = $command . $default_opts . sprintf($opts, $pack_size, $file_name);
    $this->assertEqual(
      $expected,
      $this->fast->buildCommandLine(array_merge($this->fast->defaultOptions(), $opts_args)),
      'Correctly format supplied arguments.',
      'buildCommandLine()'
    );
  }

  /**
   * Test running fast-import with no input. Requires a repository, but will not
   * produce any commits.
   */
  function testEmptyCommand() {
    $group = t('Empty command');
    list($retval, $marks, $stdout, $stderr) = $this->fast->fastImport(array(), array());
    $this->assertCommandSuccess($retval, $group);
    $this->assertNoMarks($marks, $group);
    $this->assertStatistics($stderr, $group);
  }

  /**
   * Test the 'progress' command of fast-import.
   */
  function testProgressCommand() {
    $group = t('progress command')
    // Generate some messages
    $messages[] = $this->randomName();
    $messages[] = $this->randomName();
    $messages[] = $this->randomName();
    $messages[] = $this->randomName();

    foreach ($messages as $message) {
      $commands[] = array(
        'command' => 'progress',
        'message' => $message,
      );
    }

    $options = array();
    list($retval, $marks, $stdout, $stderr) = $this->fast->fastImport($commands, $options);

    $this->assertCommandSuccess($retval, $group);
    $this->assertNoMarks($marks, $group);

    foreach($messages as $message) {
      $this->assertTrue(
        is_int(strpos($stdout, 'progress '. $message)),
        t('Make sure assigned message appears in stdout.'),
        $group
      );
    }
  }

  /**
   * Test the 'checkpoint' command.
   */
  function testCheckpointCommand() {
    $group = t('checkpoint command');
    $commands[] = array(
      'command' => 'checkpoint',
    );
    $options = array();
    list($retval, $marks, $stdout, $stderr) = $this->fast->fastImport($commands, $options);

    $this->assertCommandSuccess($retval, $group);
    $this->assertNoMarks($marks, $group);
  }
}
// ------------ lixlpixel recursive PHP functions -------------
// recursive_remove_directory( directory to delete, empty )
// expects path to directory and optional TRUE / FALSE to empty
// ------------------------------------------------------------
function recursive_remove_directory($directory, $empty=FALSE) {
  if(substr($directory,-1) == '/') {
    $directory = substr($directory,0,-1);
  }
  if(!file_exists($directory) || !is_dir($directory)) {
    return FALSE;
  } elseif(is_readable($directory)) {
    $handle = opendir($directory);
    while (FALSE !== ($item = readdir($handle))) {
      if($item != '.' && $item != '..') {
        $path = $directory.'/'.$item;
        if(is_dir($path)) {
          recursive_remove_directory($path);
        } else {
          unlink($path);
        }
      }
    }
    closedir($handle);
    if($empty == FALSE) {
      if(!rmdir($directory)) {
        return FALSE;
      }
    }
  }
  return TRUE;
}
